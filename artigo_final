optimal_p_values <- numeric(121)
residual_variances_ar <- numeric(121)
intercepts_ar <- numeric(121)

# Loop through each time series
for (i in 1:121) {
  time_series <- yields[, i]
  
  # Initialize variables to store minimum BIC and optimal p
  min_bic <- Inf
  optimal_p <- 0
  
  # Try AR models with different values of p
  for (p in 1:10) {  # You can adjust the range of p as needed
    arima_model <- arima(time_series, order = c(p, 0, 0))
    bic <- AIC(arima_model, k = log(length(time_series)))
    
    # Update optimal p if current model has lower BIC
    if (bic < min_bic) {
      min_bic <- bic
      optimal_p <- p
    }
  }
  
  final_arima_model <- arima(time_series, order = c(optimal_p, 0, 0))
  residual_variances_ar[i] <- var(resid(final_arima_model))
  intercepts_ar[i] <- final_arima_model$coef[1]  # 1 corresponds to the intercept coefficient
  optimal_p_values[i] <- optimal_p
}




#========================================================================================================================================================================



theta <- 0.00001
#Omega_apr [NxN] is the covariance matrix of Phi_1h, which, based on (2), equals to:
Omega_apr <- matrix( nrow =  length(residual_variances_ar), ncol =  length(residual_variances_ar))
for (i in 1:length(residual_variances_ar)) {
  for (j in 1:length(residual_variances_ar)) {
    Omega_apr[i, j] <- theta * residual_variances_ar[i] / residual_variances_ar[j]
  }
}

det(Omega_apr)

H <- 120
T <- nrow(yields)
N <- ncol(yields)

X_list <- vector("list", length = H)
yieldsX <- cbind(rep(1, T), yields)
for (h in 1:H) {
  X_list[[h]] <- yieldsX[(1):(T - h), ]
}

#View(X_list[[1]])

# There are H Y_h matrixes. For h = 1:H, Y_h is the (T-h)xN matrix: for i in 1:(T-h) Y[i,] <- yields[(h+i),]
Y_list <- vector("list", length = H)
for (h in 1:H) {
  Y_list[[h]] <- yields[(h + 1):(T ), ]
}

#View(Y_list[[1]])


# Psi_apr is a N+1 by N matrix. It is the expected value of Psi_h which is the junction of:
#the vector Phi_0h. whose expected value is intercepts_ar
Phi_0apr <- intercepts_ar

#the matrix Phi_1h[i,j] whose expected value is 0.99 if i = j and 0 if i != j.In other words, it is a diagonal matrix with all values = 0.99 
Phi_1apr <- diag(0.99, N)

Psi_apr <- matrix( nrow = N + 1, ncol = N)
Psi_apr[1, ] <- Phi_0apr
Psi_apr[2:(N + 1), ] <- Phi_1apr









#Final goal: 
# I want to make H matrixes Psi_apt_h <- solve(solve(Omega_apr) + t(X_list[[h]])%*%X)%*%(solve(Omega_apr) %*% Psi_apr + t(X_list[[h]]) %*% Y_list[[h]])

given that:
Omega_apr is an NxN matrix
Psi_apr is an (N+1)xN matrix
yields is a TxN matrix
H <- 120
T <- nrow(yields)
N <- ncol(yields)

and given that X_list and Y_list were obtained as such:

X_list <- vector("list", length = H)
yieldsX <- cbind(rep(1, T), yields)
for (h in 1:H) {
  X_list[[h]] <- yieldsX[(1):(T - h), ]
}

Y_list <- vector("list", length = H)
for (h in 1:H) {
  Y_list[[h]] <- yields[(h + 1):(T ), ]
}

#============------------------RESULT---------+++++++++++++++

# Initialize a list to store matrices
Psi_apt_list <- vector("list", length = H)

# Perform the matrix calculations
for (h in 1:H) {
  # Calculate intermediate matrices
  intermediate_matrix1 <- solve(solve(Omega_apr) + t(X_list[[h]]) %*% X_list[[h]])
  intermediate_matrix2 <- solve(Omega_apr) %*% Psi_apr + t(X_list[[h]]) %*% Y_list[[h]]
  
  # Calculate Psi_apt_h
  Psi_apt_h <- intermediate_matrix1 %*% intermediate_matrix2
  
  # Store the result in the list
  Psi_apt_list[[h]] <- Psi_apt_h
}



