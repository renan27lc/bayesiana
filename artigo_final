optimal_p_values <- numeric(121)
residual_variances_ar <- numeric(121)
intercepts_ar <- numeric(121)

# Loop through each time series
for (i in 1:121) {
  time_series <- yields[, i]
  
  # Initialize variables to store minimum BIC and optimal p
  min_bic <- Inf
  optimal_p <- 0
  
  # Try AR models with different values of p
  for (p in 1:10) {  # You can adjust the range of p as needed
    arima_model <- arima(time_series, order = c(p, 0, 0))
    bic <- AIC(arima_model, k = log(length(time_series)))
    
    # Update optimal p if current model has lower BIC
    if (bic < min_bic) {
      min_bic <- bic
      optimal_p <- p
    }
  }
  
  final_arima_model <- arima(time_series, order = c(optimal_p, 0, 0))
  residual_variances_ar[i] <- var(resid(final_arima_model))
  intercepts_ar[i] <- final_arima_model$coef[1]  # 1 corresponds to the intercept coefficient
  optimal_p_values[i] <- optimal_p
}




#========================================================================================================================================================================



theta <- 0.00001
#Omega_apr [NxN] is the covariance matrix of Phi_1h, which, based on (2), equals to:
Omega_apr <- matrix( nrow =  length(residual_variances_ar), ncol =  length(residual_variances_ar))
for (i in 1:length(residual_variances_ar)) {
  for (j in 1:length(residual_variances_ar)) {
    Omega_apr[i, j] <- theta * residual_variances_ar[i] / residual_variances_ar[j]
  }
}

Omega_apr <- matrix( nrow = length(residual_variances_ar), ncol = length(residual_variances_ar))

for (i in 1:length(residual_variances_ar)) {
  for (j in 1:length(residual_variances_ar)) {
    if (i != j) {
      Omega_apr[i, j] <- theta * residual_variances_ar[i] / residual_variances_ar[j]
    } else {
      Omega_apr[i, j] <- residual_variances_ar[i]  # Keep diagonal elements unchanged
    }
  }
}


det(Omega_apr)

H <- 96
T <- nrow(yields)
N <- ncol(yields)

X_list <- vector("list", length = H)
yieldsX <- cbind(rep(1, T), yields)
for (h in 1:H) {
  X_list[[h]] <- yieldsX[(1):(T - h), ]
}

#View(X_list[[1]])

# There are H Y_h matrixes. For h = 1:H, Y_h is the (T-h)xN matrix: for i in 1:(T-h) Y[i,] <- yields[(h+i),]
Y_list <- vector("list", length = H)
for (h in 1:H) {
  Y_list[[h]] <- yields[(h + 1):(T ), ]
}

#View(Y_list[[1]])


# Psi_apr is a N+1 by N matrix. It is the expected value of Psi_h which is the junction of:
#the vector Phi_0h. whose expected value is intercepts_ar
Phi_0apr <- intercepts_ar

#the matrix Phi_1h[i,j] whose expected value is 0.99 if i = j and 0 if i != j.In other words, it is a diagonal matrix with all values = 0.99 
Phi_1apr <- diag(0.99, N)

Psi_apr <- matrix( nrow = N + 1, ncol = N)
Psi_apr[1, ] <- Phi_0apr
Psi_apr[2:(N + 1), ] <- Phi_1apr









#Final goal: 
# I want to make H matrixes Psi_apt_h <- solve(solve(Omega_apr) + t(X_list[[h]])%*%X)%*%(solve(Omega_apr) %*% Psi_apr + t(X_list[[h]]) %*% Y_list[[h]])

given that:
Omega_apr is an NxN matrix
Psi_apr is an (N+1)xN matrix
yields is a TxN matrix
H <- 120
T <- nrow(yields)
N <- ncol(yields)

and given that X_list and Y_list were obtained as such:

X_list <- vector("list", length = H)
yieldsX <- cbind(rep(1, T), yields)
for (h in 1:H) {
  X_list[[h]] <- yieldsX[(1):(T - h), ]
}

Y_list <- vector("list", length = H)
for (h in 1:H) {
  Y_list[[h]] <- yields[(h + 1):(T ), ]
}

#============------------------RESULT---------+++++++++++++++

# Initialize a list to store matrices
Psi_apt_list <- vector("list", length = H)

# Perform the matrix calculations
for (h in 1:H) {
  # Calculate intermediate matrices
  intermediate_matrix1 <- solve(solve(Omega_apr) + t(X_list[[h]]) %*% as.matrix(X_list[[h]]))
  intermediate_matrix2 <- solve(Omega_apr) %*% Psi_apr + t(X_list[[h]]) %*% as.matrix(Y_list[[h]])
  
  # Calculate Psi_apt_h
  Psi_apt_h <- intermediate_matrix1 %*% intermediate_matrix2
  
  # Store the result in the list
  Psi_apt_list[[h]] <- Psi_apt_h
}







#==============================-----SEM INTERCEPTO FODASS------============================================================


optimal_p_values <- numeric(121)
residual_variances_ar <- numeric(121)
intercepts_ar <- numeric(121)

# Loop through each time series
for (i in 1:121) {
  time_series <- yields[, i]
  
  # Initialize variables to store minimum BIC and optimal p
  min_bic <- Inf
  optimal_p <- 0
  
  # Try AR models with different values of p
  for (p in 1:10) {  # You can adjust the range of p as needed
    arima_model <- arima(time_series, order = c(p, 0, 0))
    bic <- AIC(arima_model, k = log(length(time_series)))
    
    # Update optimal p if current model has lower BIC
    if (bic < min_bic) {
      min_bic <- bic
      optimal_p <- p
    }
  }
  
  final_arima_model <- arima(time_series, order = c(optimal_p, 0, 0))
  residual_variances_ar[i] <- var(resid(final_arima_model))
  intercepts_ar[i] <- final_arima_model$coef[1]  # 1 corresponds to the intercept coefficient
  optimal_p_values[i] <- optimal_p
}


theta <- 0.00001
#Omega_apr [NxN] is the covariance matrix of Phi_1h, which, based on (2), equals to:
Omega_apr <- matrix( nrow =  length(residual_variances_ar), ncol =  length(residual_variances_ar))
for (i in 1:length(residual_variances_ar)) {
  for (j in 1:length(residual_variances_ar)) {
    Omega_apr[i, j] <- theta * residual_variances_ar[i] / residual_variances_ar[j]
  }
}

Omega_apr <- matrix( nrow = length(residual_variances_ar), ncol = length(residual_variances_ar))

for (i in 1:length(residual_variances_ar)) {
  for (j in 1:length(residual_variances_ar)) {
    if (i != j) {
      Omega_apr[i, j] <- theta * residual_variances_ar[i] / residual_variances_ar[j]
    } else {
      Omega_apr[i, j] <- residual_variances_ar[i]  # Keep diagonal elements unchanged
    }
  }
}


det(Omega_apr)

H <- 120
T <- nrow(yields)
N <- ncol(yields)

X_list <- vector("list", length = H)
for (h in 1:H) {
  X_list[[h]] <- yields[(1):(T - h), ]
}

#View(X_list[[1]])

# There are H Y_h matrixes. For h = 1:H, Y_h is the (T-h)xN matrix: for i in 1:(T-h) Y[i,] <- yields[(h+i),]
Y_list <- vector("list", length = H)
for (h in 1:H) {
  Y_list[[h]] <- yields[(h + 1):(T ), ]
}

# Initialize a list to store matrices
Psi_apt_list <- vector("list", length = H)

Phi_1apr <- diag(0.99, N)

# Perform the matrix calculations
for (h in 1:H) {
  # Calculate intermediate matrices
  intermediate_matrix1 <- solve(solve(Omega_apr) + t(X_list[[h]]) %*% as.matrix(X_list[[h]]))
  intermediate_matrix2 <- solve(Omega_apr) %*% Phi_1apr + t(X_list[[h]]) %*% as.matrix(Y_list[[h]])
  
  # Calculate Psi_apt_h
  Psi_apt_h <- intermediate_matrix1 %*% intermediate_matrix2
  
  # Store the result in the list
  Psi_apt_list[[h]] <- Psi_apt_h
}




#==============================-----ROLLING WINDOW = 108, H=1, ar(6) fixed 108 window, NO INTERCEPT------============================================================



optimal_p_values <- numeric(121)
residual_variances_ar <- numeric(121)
intercepts_ar <- numeric(121)

# Loop through each time series
for (i in 1:121) {
  time_series <- yields[1:108, i]
  
  # Initialize variables to store minimum BIC and optimal p
  min_bic <- Inf
  optimal_p <- 0
  
  # Try AR models with different values of p
  for (p in 1:10) {  # You can adjust the range of p as needed
    arima_model <- arima(time_series, order = c(p, 0, 0))
    bic <- AIC(arima_model, k = log(length(time_series)))
    
    # Update optimal p if current model has lower BIC
    if (bic < min_bic) {
      min_bic <- bic
      optimal_p <- p
    }
  }
  
  final_arima_model <- arima(time_series, order = c(optimal_p, 0, 0))
  residual_variances_ar[i] <- var(resid(final_arima_model))
  intercepts_ar[i] <- final_arima_model$coef[1]  # 1 corresponds to the intercept coefficient
  optimal_p_values[i] <- optimal_p
}

theta <- 0.00001
Omega_apr <- matrix( nrow =  length(residual_variances_ar), ncol =  length(residual_variances_ar))
for (i in 1:length(residual_variances_ar)) {
  for (j in 1:length(residual_variances_ar)) {
    Omega_apr[i, j] <- theta * residual_variances_ar[i] / residual_variances_ar[j]
  }
}

Omega_apr <- matrix( nrow = length(residual_variances_ar), ncol = length(residual_variances_ar))

for (i in 1:length(residual_variances_ar)) {
  for (j in 1:length(residual_variances_ar)) {
    if (i != j) {
      Omega_apr[i, j] <- theta * residual_variances_ar[i] / residual_variances_ar[j]
    } else {
      Omega_apr[i, j] <- residual_variances_ar[i]  # Keep diagonal elements unchanged
    }
  }
}


det(Omega_apr)


H <- 12
T <- nrow(yields)
N <- ncol(yields)
W <- 108

Y_list <- vector("list", length = H)
for (h in 1:H) {
  matrices <- vector("list", length = T - W - h + 1) 
  for (t in 1:(T - W - h + 1)) {
    start_index <- t + 1
    end_index <- t + W - 1
    matrices[[t]] <- yields[start_index:end_index, ]
  }
    Y_list[[h]] <- matrices
}

X_list <- vector("list", length = H)
for (h in 1:H) {
  matrices <- vector("list", length = T - W - h + 1)
  
  for (t in 1:(T - W - h + 1)) {
    start_index <- t
    end_index <- t + W - 2
    matrices[[t]] <- yields[start_index:end_index, ]
  }  
  X_list[[h]] <- matrices
}

# Initialize a list to store matrices
Psi_apt_h1_list <- vector("list", length = (T - W))

Phi_1apr <- diag(0.99, N)

X_list_h1<-X_list[[1]]
Y_list_h1<-Y_list[[1]]

# Perform the matrix calculations
for (t in 1:(T - W)) {
  # Calculate intermediate matrices
  intermediate_matrix1_h1 <- solve(solve(Omega_apr) + t(X_list_h1[[t]]) %*% as.matrix(X_list_h1[[t]]))
  intermediate_matrix2_h1 <- solve(Omega_apr) %*% Phi_1apr + t(X_list_h1[[t]]) %*% as.matrix(Y_list_h1[[t]])
  
  # Calculate Psi_apt_h
  Psi_apt_h1_t <- intermediate_matrix1_h1 %*% intermediate_matrix2_h1
  
  # Store the result in the list
  Psi_apt_h1_list[[t]] <- Psi_apt_h1_t
}


